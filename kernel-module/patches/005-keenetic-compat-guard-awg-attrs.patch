From: Keenetic SDK Builder <developers@keenetic.com>
Subject: [PATCH] netlink: strip ALL AWG attrs from GET_DEVICE for Keenetic

Keenetic NDMS expects GET_DEVICE responses to contain only standard
WireGuard attributes: LISTEN_PORT, FWMARK, IFINDEX, IFNAME,
PRIVATE_KEY, PUBLIC_KEY, PEERS. No AWG-specific device or peer
attributes should be present.

The native Keenetic wireguard.ko (ndm-20200623) never sends JC, JMIN,
JMAX, S1, S2, H1-H4 or any AWG attrs in GET_DEVICE â€” NDMS knows
the AWG config because it set them itself via SET_DEVICE.

Strip ALL AWG attributes from GET_DEVICE response:
1. Device level: remove JC/JMIN/JMAX/S1/S2/H1-H4/S3/S4/I1-I5
2. Peer level: remove FLAGS and ADVANCED_SECURITY

Signed-off-by: Keenetic SDK Builder <developers@keenetic.com>
---
 src/netlink.c | 38 +-------------------------------------
 1 file changed, 1 insertion(+), 37 deletions(-)

--- a/src/netlink.c
+++ b/src/netlink.c
@@ -289,14 +289,4 @@
 			return ret;
 	}

-	fail = nla_put_u32(skb, WGPEER_A_FLAGS, WGPEER_F_HAS_ADVANCED_SECURITY);
-	if (fail)
-		goto err;
-
-	if (peer->advanced_security) {
-		fail = nla_put_flag(skb, WGPEER_A_ADVANCED_SECURITY);
-		if (fail)
-			goto err;
-	}
-
 	down_read(&peer->handshake.lock);
@@ -417,7 +407,6 @@
 	int ret = -EMSGSIZE;
 	bool done = true;
 	void *hdr;
-	char buf[32];

 	rtnl_lock();
 	mutex_lock(&wg->device_update_lock);
@@ -435,32 +424,7 @@
 				wg->incoming_port) ||
 		    nla_put_u32(skb, WGDEVICE_A_FWMARK, wg->fwmark) ||
 		    nla_put_u32(skb, WGDEVICE_A_IFINDEX, wg->dev->ifindex) ||
-		    nla_put_string(skb, WGDEVICE_A_IFNAME, wg->dev->name) ||
-		    nla_put_u16(skb, WGDEVICE_A_JC, wg->jc) ||
-		    nla_put_u16(skb, WGDEVICE_A_JMIN, wg->jmin) ||
-		    nla_put_u16(skb, WGDEVICE_A_JMAX, wg->jmax) ||
-		    nla_put_u16(skb, WGDEVICE_A_S1, wg->junk_size[MSGIDX_HANDSHAKE_INIT]) ||
-		    nla_put_u16(skb, WGDEVICE_A_S2,wg->junk_size[MSGIDX_HANDSHAKE_RESPONSE]) ||
-		    (mh_genspec(&wg->headers[MSGIDX_HANDSHAKE_INIT], buf, sizeof(buf)) &&
-				nla_put_string(skb, WGDEVICE_A_H1, buf)) ||
-			(mh_genspec(&wg->headers[MSGIDX_HANDSHAKE_RESPONSE], buf, sizeof(buf)) &&
-				nla_put_string(skb, WGDEVICE_A_H2, buf)) ||
-			(mh_genspec(&wg->headers[MSGIDX_HANDSHAKE_COOKIE], buf, sizeof(buf)) &&
-				nla_put_string(skb, WGDEVICE_A_H3, buf)) ||
-			(mh_genspec(&wg->headers[MSGIDX_TRANSPORT], buf, sizeof(buf)) &&
-				nla_put_string(skb, WGDEVICE_A_H4, buf)) ||
-			nla_put_u16(skb, WGDEVICE_A_S3, wg->junk_size[MSGIDX_HANDSHAKE_COOKIE]) ||
-			nla_put_u16(skb, WGDEVICE_A_S4, wg->junk_size[MSGIDX_TRANSPORT]) ||
-			(wg->ispecs[0].desc &&
-				nla_put_string(skb, WGDEVICE_A_I1, wg->ispecs[0].desc)) ||
-			(wg->ispecs[1].desc &&
-				nla_put_string(skb, WGDEVICE_A_I2, wg->ispecs[1].desc)) ||
-			(wg->ispecs[2].desc &&
-				nla_put_string(skb, WGDEVICE_A_I3, wg->ispecs[2].desc)) ||
-			(wg->ispecs[3].desc &&
-				nla_put_string(skb, WGDEVICE_A_I4, wg->ispecs[3].desc)) ||
-			(wg->ispecs[4].desc &&
-				nla_put_string(skb, WGDEVICE_A_I5, wg->ispecs[4].desc)))
+		    nla_put_string(skb, WGDEVICE_A_IFNAME, wg->dev->name))
 			goto out;

 		down_read(&wg->static_identity.lock);
